/*
 * (C) Copyright 2024, SECO Mind Srl
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#ifndef E2EUTILITIES_H
#define E2EUTILITIES_H

#include "astarte_device_sdk/interface.h"
#include "e2erunner.h"

#include <stdlib.h>

/**
 * @file e2eutilities.h
 * @brief Utilities needed in e2e tests
 */

#define CHECK_HALT(expr, ...)                                                                      \
    if (expr) {                                                                                    \
        LOG_ERR(__VA_ARGS__); /* NOLINT */                                                         \
        k_fatal_halt(-1);                                                                          \
    }

#define CHECK_ASTARTE_OK_HALT(expr, ...) CHECK_HALT(expr != ASTARTE_RESULT_OK, __VA_ARGS__)

// TYPE parameter must be a type name
// (it mustn't be space separated or the macro will break it is used in the function name)
#define ALLOC_ARRAY_FROM_STATIC_FN_DECLARATION(TYPE)                                               \
    TYPE *TYPE##_from_static(TYPE *array_ptr, size_t len);

// TYPE parameter must be a type name
// (it mustn't be space separated or the macro will break it is used in the function name)
#define ALLOC_ARRAY_FROM_STATIC_FN_DEFINITION(TYPE)                                                \
    TYPE *TYPE##_from_static(TYPE *array_ptr, size_t len)                                          \
    {                                                                                              \
        TYPE *result = calloc(len, sizeof(TYPE));                                                  \
        CHECK_HALT(!result, "Could not allocate array of type '" STRINGIFY(TYPE) "'");             \
        for (size_t i = 0; i < len; ++i) {                                                         \
            result[i] = array_ptr[i];                                                              \
        }                                                                                          \
        return result;                                                                             \
    }

// before calling this macro create the allocation function using the macro ALLOC_ARRAY_FROM_STATIC
// the arrays generated by this macro and stored in buf need to be dellocated
// if there are other pointer stored in the array values they should be constant
// expanded into the macro
#define DYNAMIC_ARRAY(TYPE, ARRAY_LITERAL)                                                         \
    {                                                                                              \
        .buf = TYPE##_from_static((ARRAY_LITERAL), ARRAY_SIZE(ARRAY_LITERAL)),                     \
        .len = ARRAY_SIZE(ARRAY_LITERAL),                                                          \
    }

// DYNAMIC_ARRAY e2e mapping helper functions
ALLOC_ARRAY_FROM_STATIC_FN_DECLARATION(e2e_individual_data_t)

// DYNAMIC_ARRAY e2e interfaces helper functions
ALLOC_ARRAY_FROM_STATIC_FN_DECLARATION(e2e_interface_data_t)

// DYNAMIC_ARRAY astarte pair allocation helper function
ALLOC_ARRAY_FROM_STATIC_FN_DECLARATION(astarte_object_entry_t)

// DYNAMIC_ARRAY e2e property value allocation helper function
ALLOC_ARRAY_FROM_STATIC_FN_DECLARATION(e2e_property_data_t)

void free_e2e_interfaces_array(e2e_interface_data_array interfaces_array);

e2e_interface_data_t *get_e2e_interface(
    e2e_interface_data_array *interfaces_array, const char *interface_name);

const e2e_individual_data_t *get_e2e_mapping(
    const e2e_mapping_data_array *mapping_array, const char *endpoint);

const astarte_object_entry_t *get_pair_mapping(
    const e2e_object_entry_array *value_pair_array, const char *endpoint);

bool astarte_value_equal(astarte_individual_t *a, astarte_individual_t *b);

// makes an e2e individual interface with the correct union type
e2e_interface_data_t e2e_interface_from_interface_individual(
    const astarte_interface_t *interface, e2e_mapping_data_array mappings);

// makes an e2e object interface with the correct union type
e2e_interface_data_t e2e_interface_from_interface_object(
    const astarte_interface_t *interface, e2e_object_data_t object_value);

// makes an e2e property interface with the correct union type
e2e_interface_data_t e2e_interface_from_interface_property(
    const astarte_interface_t *interface, e2e_property_data_array properties);

#endif /* E2EUTILITIES_H */

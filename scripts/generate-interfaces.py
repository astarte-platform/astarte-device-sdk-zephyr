# (C) Copyright 2024, SECO Mind Srl
#
# SPDX-License-Identifier: Apache-2.0

"""docs.py

West extension that can be used to build doxygen documentation for this project.

Checked using pylint with the following command (pip install pylint):
python -m pylint --rcfile=./scripts/.pylintrc ./scripts/*.py
Formatted using black with the following command (pip install black):
python -m black --line-length 100 ./scripts/*.py
"""

import os
import subprocess
from pathlib import Path
from string import Template

import json
from astarte.device import Interface
from west.commands import WestCommand  # your extension must subclass this

# from west import log  # use this for user output

static_name = "generate-interfaces"
static_help = "Generate interfaces header"
static_description = """Convenience script to automatically generate the interfaces code from an interfaces directory."""


class WestCommandGenerateInterfaces(WestCommand):
    """Extension of the WestCommand class, specific for this command."""

    def __init__(self):
        super().__init__(static_name, static_help, static_description)

    def do_add_parser(self, parser_adder):
        """
        This function can be used to add custom options for this command.

        Allows you full control over the type of argparse handling you want.

        Parameters
        ----------
        parser_adder : Any
            Parser adder generated by a call to `argparse.ArgumentParser.add_subparsers()`.

        Returns
        -------
        argparse.ArgumentParser
            The argument parser for this command.
        """
        parser = parser_adder.add_parser(self.name, help=self.help, description=self.description)

        # Add some options using the standard argparse module API.
        parser.add_argument(
            "interfaces", help="Path of the directory containing the interfaces json file", action="store"
        )

        return parser  # gets stored as self.parser

    # pylint: disable-next=arguments-renamed,unused-argument
    def do_run(self, args, unknown_args):
        """
        Function called when the user runs the custom command, e.g.:

          $ west clean

        Parameters
        ----------
        args : Any
            Arguments pre parsed by the parser defined by `do_add_parser()`.
        unknown_args : Any
            Extra unknown arguments.
        """
        module_dir = Path(self.topdir).joinpath("astarte-device-sdk-zephyr")
        sources_dir = module_dir.joinpath("lib/generated")
        headers_dir = module_dir.joinpath("include/generated")
        interfaces_dir = Path(args.interfaces)

        generate_interfaces(interfaces_dir, headers_dir, sources_dir)
        

mapping_reliability_lookup = {
    0: "RELIABILITY_UNRELIABLE",
    1: "RELIABILITY_GUARANTEED",
    2: "RELIABILITY_UNIQUE",
}

interface_header_template = Template(
    r"""/*
 * (C) Copyright 2023, SECO Mind Srl
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later OR Apache-2.0
 */

/**
 * @file astarte_interface_gen.h
 * @brief Contains automatically generated interfaces.
 *
 * @details The generated structures contain all information regarding each interface.
 * and are automatically generated from the json interfaces definitions.
 */

#ifndef _ASTARTE_INTERFACE_GEN_H_
#define _ASTARTE_INTERFACE_GEN_H_

#include <astarte_device_sdk/interface.h>
#include <astarte_device_sdk/mapping.h>

${interfaces_declarations}

#endif /* _ASTARTE_INTERFACE_GEN_H_ */
"""
)

interface_source_template = Template(
    r"""/*
 * (C) Copyright 2023, SECO Mind Srl
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later OR Apache-2.0
 */

/**
 * @file astarte_interface_gen.c
 * @brief Contains automatically generated interfaces.
 */

#include <generated/astarte_interface_gen.h>
${interfaces_declarations}
"""
)

interface_declaration_template = Template(
    r"""extern const ad_interface_t ad_interface_${interface_name_sc};"""
)

interface_definition_template = Template(
    r"""
const ad_mapping_t ad_mappings_${interface_name_sc}[${mappings_number}] = {
${mappings}
};

const ad_mapping_list_t ad_interface_mapping_list_${interface_name_sc} = {
    .buf = ad_mappings_${interface_name_sc},
    .len = ${mappings_number},
}

const ad_interface_t ad_interface_${interface_name_sc} = {
    .name = "${interface_name}",
    .major_version = ${version_major},
    .minor_version = ${version_minor},
    .type = ${type},
    .ownership = ${ownership},
    .aggregation = ${aggregation},
    .mappings = ad_interface_mapping_list_${interface_name_sc},
};"""
)

mapping_definition_template = Template(
    r"""
    {
        .endpoint = "${endpoint}",
        .type = ${type},
        .reliability = ${reliability},
        .explicit_timestamp = ${explicit_timestamp},
        .allow_unset =  ${allow_unset},
    },"""
)

def generate_interfaces(interfaces_dir: Path, header_dir: Path, source_dir: Path):
    """
    Generate the C files defining a set of interfaces starting from .json definitions.

    Parameters
    ----------
    interfaces_dir : Path
        Folder in which to search for .json files.
    header_dir : Path
        Folder where the generated header fill will be saved.
    source_dir : Path
        Folder where the generated source fill will be saved.
    """

    # Iterate over all the interfaces
    interfaces_declarations = []
    interfaces_structs = []
    for interface_file in [i for i in interfaces_dir.iterdir() if i.suffix == ".json"]:
        with open(interface_file, "r", encoding="utf-8") as interface_fp:
            interface_json = json.load(interface_fp)
            interface = Interface(interface_json)

            # Iterate over each mapping
            mappings_struct = []
            for mapping in interface.mappings:
                # Fill in the mapping information in the template
                mapping_struct = mapping_definition_template.substitute(
                    endpoint=mapping.endpoint,
                    type="TYPE_" + mapping.type.upper(),
                    reliability=mapping_reliability_lookup[mapping.reliability],
                    explicit_timestamp="true" if mapping.explicit_timestamp else "false",
                    allow_unset="true" if mapping.allow_unset else "false",
                )
                mappings_struct.append(mapping_struct)

            # Fill in the interface information in the template
            itype = "TYPE_PROPERTIES" if interface.is_type_properties() else "TYPE_DATASTREAM"
            iownership = "OWNERSHIP_SERVER" if interface.is_server_owned() else "OWNERSHIP_DEVICE"
            iaggregation = (
                "AGGREGATION_OBJECT"
                if interface.is_aggregation_object()
                else "AGGREGATION_INDIVIDUAL"
            )
            interface_struct = interface_definition_template.substitute(
                mappings_number=len(interface.mappings),
                interface_name_sc=interface.name.replace(".", "_"),
                interface_name=interface.name,
                version_major=interface.version_major,
                version_minor=interface.version_minor,
                type=itype,
                ownership=iownership,
                aggregation=iaggregation,
                mappings="".join(mappings_struct),
            )
            interfaces_structs.append(interface_struct)

            # Fill in the extern definition
            interface_declaration = interface_declaration_template.substitute(
                interface_name_sc=interface.name.replace(".", "_")
            )
            interfaces_declarations.append(interface_declaration)

    # Fill in the header
    interfaces_header = interface_header_template.substitute(
        interfaces_declarations="\n".join(interfaces_declarations)
    )

    interfaces_source = interface_source_template.substitute(
        interfaces_declarations="\n".join(interfaces_structs)
    )

    # Generate directories
    if not header_dir.exists():
        os.makedirs(header_dir)

    if not source_dir.exists():
        os.makedirs(source_dir)

    # generate files
    generated_header = header_dir.joinpath("astarte_interface_gen.h")
    with open(generated_header, "w", encoding="utf-8") as generated_fp:
        generated_fp.write(interfaces_header)

    generated_source = source_dir.joinpath("astarte_interface_gen.c")
    with open(generated_source, "w", encoding="utf-8") as generated_fp:
        generated_fp.write(interfaces_source)

# (C) Copyright 2024, SECO Mind Srl
#
# SPDX-License-Identifier: Apache-2.0

"""docs.py

West extension that can be used to generate interfaces definitions.

Checked using pylint with the following command (pip install pylint):
python -m pylint --rcfile=./scripts/.pylintrc ./scripts/*.py
Formatted using black with the following command (pip install black):
python -m black --line-length 100 ./scripts/*.py
"""

import difflib
import json
import os
import re
import sys
from pathlib import Path
from string import Template
import subprocess

from astarte.device import Interface
from colored import fore, stylize
from west import log
from west.commands import WestCommand

static_name = "generate-interfaces"
static_help = "Generate interfaces header(s)"
static_description = """Generates C interfaces definitions from .json definitions."""


class WestCommandGenerateInterfaces(WestCommand):
    """Extension of the WestCommand class, specific for this command."""

    def __init__(self):
        super().__init__(static_name, static_help, static_description)

    def do_add_parser(self, parser_adder):
        """
        This function can be used to add custom options for this command.

        Allows you full control over the type of argparse handling you want.

        Parameters
        ----------
        parser_adder : Any
            Parser adder generated by a call to `argparse.ArgumentParser.add_subparsers()`.

        Returns
        -------
        argparse.ArgumentParser
            The argument parser for this command.
        """
        parser = parser_adder.add_parser(self.name, help=self.help, description=self.description)

        # Add some options using the standard argparse module API.
        parser.add_argument("json_dir", help="Directory containing the interfaces .json file(s).")
        parser.add_argument(
            "-p",
            "--output_prefix",
            help="Prefix to add to all generated sources.",
            type=str,
            default="",
        )
        parser.add_argument(
            "-d",
            "--output_dir",
            help="Directory where the generated headers will be stored.",
            default=None,
        )
        parser.add_argument(
            "-c",
            "--check",
            help="Check if previously generated interfaces are up to date." 
                + "The check does not include any whitespace character.",
            action="store_true",
        )

        return parser  # gets stored as self.parser

    # pylint: disable-next=arguments-renamed,unused-argument
    def do_run(self, args, unknown_args):
        """
        Function called when the user runs the custom command, e.g.:

          $ west generate-interfaces ...

        Parameters
        ----------
        args : Any
            Arguments pre parsed by the parser defined by `do_add_parser()`.
        unknown_args : Any
            Extra unknown arguments.
        """
        interfaces_dir = Path(args.json_dir).absolute()
        output_dir = Path(args.output_dir).absolute() if args.output_dir else interfaces_dir
        output_filename = args.output_prefix + "generated_interfaces"

        generate_interfaces(interfaces_dir, output_dir, output_filename, args.check)


reliability_lookup = {
    0: "UNRELIABLE",
    1: "GUARANTEED",
    2: "UNIQUE",
}

interface_header_template = Template(
    r"""/**
 * @file ${output_filename}.h
 * @brief Contains automatically generated interfaces.
 *
 * @warning Do not modify this file manually.
 *
 * @details The generated structures contain all information regarding each interface.
 * and are automatically generated from the json interfaces definitions.
 */

// NOLINTNEXTLINE This guard is clear enough.
#ifndef ${output_filename_cap}_H
#define ${output_filename_cap}_H

#include <astarte_device_sdk/interface.h>
#include <astarte_device_sdk/mapping.h>

// Interface names should resemble as closely as possible their respective .json file names.
// NOLINTBEGIN(readability-identifier-naming)
${interfaces_declarations}
// NOLINTEND(readability-identifier-naming)

#endif /* ${output_filename_cap}_H */
"""
)

interface_source_template = Template(
    r"""/**
 * @file ${output_filename}.c
 * @brief Contains automatically generated interfaces.
 *
 * @warning Do not modify this file manually.
 */

#include "${output_filename}.h"

// Interface names should resemble as closely as possible their respective .json file names.
// NOLINTBEGIN(readability-identifier-naming)
${interfaces_declarations}

// NOLINTEND(readability-identifier-naming)
"""
)

interface_declaration_template = Template(
    r"""extern const astarte_interface_t ${interface_name_sc};"""
)

interface_definition_template = Template(
    r"""
static const astarte_mapping_t ${interface_name_sc}_mappings[${mappings_number}] = {
${mappings}
};

const astarte_interface_t ${interface_name_sc} = {
    .name = "${interface_name}",
    .major_version = ${version_major},
    .minor_version = ${version_minor},
    .type = ${type},
    .ownership = ${ownership},
    .aggregation = ${aggregation},
    .mappings = ${interface_name_sc}_mappings,
    .mappings_length = ${mappings_number}U,
};"""
)

mapping_definition_template = Template(
    r"""
    {
        .endpoint = "${endpoint}",
        .regex_endpoint = "${regex_endpoint}",
        .type = ${type},
        .reliability = ${reliability},
        .explicit_timestamp = ${explicit_timestamp},
        .allow_unset = ${allow_unset},
    },"""
)


# pylint: disable-next=too-many-locals
def generate_interfaces(interfaces_dir: Path, output_dir: Path, output_fn: str, check: bool):
    """
    Generate the C files defining a set of interfaces starting from .json definitions.

    Parameters
    ----------
    interfaces_dir : Path
        Folder in which to search for .json files.
    output_dir : Path
        Folder where the generated files will be saved.
    output_fn : str
        Output file name without extension.
    check : bool
        Check if previously generated interfaces are up to date.
        The check does not include any whitespace character (\s)
    """

    # Iterate over all the interfaces
    interfaces_declarations = []
    interfaces_structs = []
    for interface_file in sorted([i for i in interfaces_dir.iterdir() if i.suffix == ".json"]):
        with open(interface_file, "r", encoding="utf-8") as interface_fp:
            interface_json = json.load(interface_fp)
            interface = Interface(interface_json)

            # Iterate over each mapping
            mappings_struct = []
            for mapping in interface.mappings:
                # Fill in the mapping information in the template
                mapping_struct = mapping_definition_template.substitute(
                    endpoint=mapping.endpoint,
                    regex_endpoint=re.sub(
                        r"%{([a-zA-Z_][a-zA-Z0-9_]*)}",
                        r"[a-zA-Z_][a-zA-Z0-9_]*",
                        mapping.endpoint,
                    ),
                    type="ASTARTE_MAPPING_TYPE_" + mapping.type.upper(),
                    reliability="ASTARTE_MAPPING_RELIABILITY_"
                    + reliability_lookup[mapping.reliability],
                    explicit_timestamp="true" if mapping.explicit_timestamp else "false",
                    allow_unset="true" if mapping.allow_unset else "false",
                )
                mappings_struct.append(mapping_struct)

            # Fill in the interface information in the template
            itype = "ASTARTE_INTERFACE_" + (
                "TYPE_PROPERTIES" if interface.is_type_properties() else "TYPE_DATASTREAM"
            )
            iownership = "ASTARTE_INTERFACE_" + (
                "OWNERSHIP_SERVER" if interface.is_server_owned() else "OWNERSHIP_DEVICE"
            )
            iaggregation = "ASTARTE_INTERFACE_" + (
                "AGGREGATION_OBJECT"
                if interface.is_aggregation_object()
                else "AGGREGATION_INDIVIDUAL"
            )
            interface_struct = interface_definition_template.substitute(
                mappings_number=len(interface.mappings),
                interface_name_sc=interface.name.replace(".", "_"),
                interface_name=interface.name,
                version_major=interface.version_major,
                version_minor=interface.version_minor,
                type=itype,
                ownership=iownership,
                aggregation=iaggregation,
                mappings="".join(mappings_struct),
            )
            interfaces_structs.append(interface_struct)

            # Fill in the extern definition
            interface_declaration = interface_declaration_template.substitute(
                interface_name_sc=interface.name.replace(".", "_")
            )
            interfaces_declarations.append(interface_declaration)

    # Fill in the header
    interfaces_header = interface_header_template.substitute(
        output_filename=output_fn,
        output_filename_cap=output_fn.upper(),
        interfaces_declarations="\n".join(interfaces_declarations),
    )

    interfaces_source = interface_source_template.substitute(
        output_filename=output_fn, interfaces_declarations="\n".join(interfaces_structs)
    )

    # Write the output files if required
    generated_header = output_dir.joinpath(f"{output_fn}.h")
    generated_source = output_dir.joinpath(f"{output_fn}.c")
    if check:
        if not output_dir.exists():
            log.err(stylize("Check failed: non existant output directory", fore("yellow")))
            sys.exit(1)

        with (open(generated_header, "r", encoding="utf-8") as generated_header_fp,
            open(generated_source, "r", encoding="utf-8") as generated_source_fp):

            header = format_file(generated_header_fp.read())
            header_valid = format_file(interfaces_header)

            if header != header_valid:
                log.err(stylize("Check failed: header is not up to date", fore("yellow")))
                log.dbg(f"Valid:\n{header_valid}")
                log.dbg(f"Current:\n{header}")
                sys.exit(1)

            source = format_file(generated_source_fp.read())
            source_valid = format_file(interfaces_source)

            if source != source_valid:
                log.err(stylize("Check failed: source is not up to date", fore("yellow")))
                log.dbg(f"Valid:\n{source_valid}")
                log.dbg(f"Current:\n{source}")
                sys.exit(1)

            log.inf("Files are updated")
    else:
        # Generate directory
        if not output_dir.exists():
            os.makedirs(output_dir)

        # Generate files
        with open(generated_header, "w", encoding="utf-8") as generated_fp:
            generated_fp.write(interfaces_header)

        with open(generated_source, "w", encoding="utf-8") as generated_fp:
            generated_fp.write(interfaces_source)

def format_file(file_content: str) -> str:
    cmd = (
        ["clang-format", "--style=LLVM"]
    )
    result = subprocess.run(" ".join(cmd), shell=True, timeout=60,
        check=True, input=file_content, capture_output = True, text = True)

    return result.stdout
